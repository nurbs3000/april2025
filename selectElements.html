<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Select Multiple HTML elements with Mouse</title>
        <style> /* internal style. */
            *{ /* universal selector. Selects all elements. */
                margin: 0;
                padding: 0;
                box-sizing: border-box; /* include the padding and border in elements's total widht and height. */
                font-size: 22px; /* why not? */
            }
            #wrapper{ /* id selector. */
                width: 100vw; /* 100% of the viewport's width. */
                height: 100vh; /* 100% of the viewport's height. */
                display: flex; /* to place nicely header(holds controls) and main(JS will place radonm divs in) elements. */
                flex-direction: column; /* items are displayed verticaly (main axis is vertical). */
            }
            header{ /* the CSS type selector. */
                width: 100%; /* 100% of the parent's width. */
                height: 50px; /* enough for input number and buttons elements. */
                background-color: silver; /* your choice of color. */
                display: flex; /* to organize input elements. */
                justify-content: space-evenly; /*equal space around items on the main axis. */
                align-items: center; /* items in the center on the cross axis. */
            }
            main{ /* the CSS type selector. */
                width: 100%; /* 100% of its parent width. */
                height: 100%; /* all remaining after the header free height. */
                background-color: #222; /* your choice of color. */
                position: relative; /* to allow JS position elements inside at arbitrary coordinates. */
            }
            .children-of-main{ /* all generated by JS elements will have class="childred-of-main". */
                position: absolute; /* inline styly.top and style.left set by JS, on every generated div, will work. */
            }
            #select-rect{ /* id selector, style div, which will serve as a rectangular selection area. */
                position: absolute; /* top and left properties must work. */
                border: 3px dashed black; /* to stand out. */
                z-index: 1; /* must be on top of the rest divs. */
                display: none; /* will be set to block by JS, to be visible only during the time of selection. */
            }
        </style>
    </head>
    <body>
        <div id="wrapper"> <!-- wrapps everything. -->
            <header> <!-- semantic HTML element. It fits its topmost position in the viewport. -->
                <div>Rows
                    <input type="number" id="rowQt" min="3" max="20" value="7" autocomplete="off"> <!-- number of rows. -->
                </div>
                <div>Columns
                    <input type="number" id="colQt" min="3" max="20" value="7" autocomplete="off"> <!-- number of columns. -->
                </div>
                <button type="button" style="width:120px; background-color:firebrick;">Make red</button> <!-- button with a bit of inline style. -->
                <button type="button" style="width:120px;background-color:steelBlue">Make blue</button>
            </header>
            <main> <!-- random divs will be placed here. -->
                <div id="select-rect"></div> <!-- represents the selection area. -->
            </main>
        </div>
        <script>
//*************************** global variables **********************
const headerElem = document.querySelector("header");
const mainElem = document.querySelector("main");
const selRectElem = document.querySelector("#select-rect");
const selectedElems = []; // this array will hold selected elements.
//*************************** events ********************************
headerElem.addEventListener("input",()=>{
    generateElems(); // envoke this function, when any of two input number elements fire input event.
});
mainElem.addEventListener("mousedown",e=>{ // signifies the start of the selection act.
    selRectElem.style.left = mainXY(e).x+"px"; // calls mainXY(e) wich retruns oblect {x: mouse_hor_coor, y: mouse_ver_coor}, where mouse_coor is relative to the main top left corner coordiates.
    selRectElem.style.top = mainXY(e).y+"px"; // the same for vertical coor.
    selRectElem.style.display = "block"; // set the div, representing the selection area visible.
    e.preventDefault(); // preventDefaut() to not let browser perform drag.
});
mainElem.addEventListener("mousemove",selectRect); // envoke function, which if LMB is pressed dynamically resize the selection area div.
mainElem.addEventListener("mouseup",e=>{ // signifies the end of the selection act.
    selectDivs(selRectElem); // envoke func, passing selection area div element.
    selRectElem.style.width = "0"; // set selection div width to 0.
    selRectElem.style.height = "0"; // set selection div height to 0.
    selRectElem.style.display = "none"; // makes it invisible. Selection act is over.
});
headerElem.addEventListener("click",e=>{ // click on any of 2 button will fire this event.
    selectedElems.forEach(el=>{ // cycle through each selected element.
        el.style.backgroundColor = e.target.style.backgroundColor; // set every element's, in the  selectedElems array, bg color equal to the bg color of the button, which fire the event. 
    });
});
//*************************** logic *********************************
function selectRect(e){ // called by mousemove event.
    if(selRectElem.style.display !== "block") return; // if ... != "block" means that the selection div is invisible (no selection action is going on). No need to do anything - return.
    selRectElem.style.width = (mainXY(e).x-parseInt(selRectElem.style.left))+"px"; // calculate and set the width of the selection div.
    selRectElem.style.height = (mainXY(e).y-parseInt(selRectElem.style.top))+"px"; // the same for the height.
}
function mainXY(e){
    return {x: e.clientX-mainElem.offsetLeft, y: e.clientY-mainElem.offsetTop} // return object, which x, y properties are local mouse cursor coordinates inside main element.
}
function generateElems(){ // generate random divs and place the kinda inside a "table" with rows and columns.
    const rowQt = Number(document.querySelector("#rowQt").value); // read the value in input element for number or rows.
    const colQt = Number(document.querySelector("#colQt").value); // the same for the colums.
    const padding = 20; // to create free space near the edges.
    const cellWidth = (mainElem.clientWidth-2*padding)/colQt; // cell widht in our virtual 'table'.
    const cellHeight = (mainElem.clientHeight-2*padding)/rowQt;
    const randomDivs = document.getElementsByClassName("children-of-main"); // HTML elements collection with all elements with class="children-of-main".
    Array.prototype.slice.call(randomDivs).forEach(elem=>{
        elem.remove(); // convert the HTML collecton to array, to implement array method forEach(). Remove every element in the collection from document (div with id="select-rect" will remain).
    });
    for(let r = 0; r < rowQt; r++)
        for(let c = 0; c < colQt; c++){ // this loops will scan every cell in 'table'.
            const elem = document.createElement('div'); // create div.
            const w = cellWidth*(1/5+4/5*Math.random()); // set random widht in range from 20% to 100% of cell width.
            const h = cellHeight*(1/5+4/5*Math.random()); // the same for height.
            const left = padding+c*cellWidth+(Math.random() < .5 ? 0 : cellWidth-w); // left CSS property for the current div element, taking into account 'padding'.
            const right = padding+r*cellHeight+(Math.random() < .5 ? 0 : cellHeight-h);
            const color = `hsl(${360*Math.random()},100%,30%)`; // random hsl color.
            elem.style = `left:${left}px;top:${right}px;width:${w}px;height:${h}px;background-color:${color};` // set inline style.
            elem.className = "children-of-main"; // set class. It allows getElementsByClassName() method to be implemented. 
            mainElem.append(elem); // put created element (div) inside main.
        }
}
function selectDivs(elem){ // this func will actualy do the selection.
    const [left,top,width,height] = [parseInt(elem.style.left), parseInt(elem.style.top), parseInt(elem.style.width), parseInt(elem.style.height)]; // destructuring syntax. Consult google, if smth is unclear. Topic is too big to cover in comments.
    selectedElems.length = 0; // clear the array.
    const randomDivs = document.getElementsByClassName("children-of-main"); // get the HTML collection with all generated divs.
    Array.from(randomDivs).forEach(el=>{ // conver it to array, and implement the forEach() array method.
        el.style.border = ""; // removes the border for every element.
        const [eLeft, eTop, eWidth, eHeight] = [parseInt(el.style.left), parseInt(el.style.top), parseInt(el.style.width), parseInt(el.style.height)]; // destructuring syntax. Saves a lot of typing.
        if(eLeft < left || (eLeft+eWidth) > (left+width) || eTop < top || (eTop+eHeight) > (top+height)) return; // check if current element is outside selection area, if true - return.
        selectedElems.push(el); // if inside the selection area, means it is selected, and must be pushed in array, containing selected divs.
        el.style.border = "6px solid white"; // set white border for selected elements.
    });
}
//*************************** start here ****************************
generateElems();
//*******************************************************************
        </script>
    </body>
</html>